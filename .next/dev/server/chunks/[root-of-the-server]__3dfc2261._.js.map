{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///C:/projetos/financas/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\nconst globalForPrisma = globalThis as unknown as {\r\n  prisma: PrismaClient | undefined;\r\n};\r\n\r\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient();\r\n\r\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,sMAAY;AAEhE,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///C:/projetos/financas/src/app/api/transactions/route.ts"],"sourcesContent":["import { prisma } from \"@/lib/prisma\";\r\nimport { NextResponse } from \"next/server\";\r\n\r\nexport async function GET() {\r\n  try {\r\n    const transactions = await prisma.transaction.findMany({\r\n      include: {\r\n        category: true,\r\n        account: true,\r\n        payer: true,\r\n        owner: true,\r\n      },\r\n      orderBy: { purchaseDate: \"desc\" },\r\n      take: 500,\r\n    });\r\n    return NextResponse.json(transactions);\r\n  } catch (error) {\r\n    console.error(\"Error fetching transactions:\", error);\r\n    return NextResponse.json(\r\n      { error: \"Failed to fetch transactions\" },\r\n      { status: 500 },\r\n    );\r\n  }\r\n}\r\n\r\nexport async function POST(request: Request) {\r\n  try {\r\n    const data = await request.json();\r\n    const transaction = await prisma.transaction.create({\r\n      data: {\r\n        description: data.description,\r\n        amount: data.amount,\r\n        purchaseDate: new Date(data.purchaseDate),\r\n        paymentDate: data.paymentDate ? new Date(data.paymentDate) : null,\r\n        type: data.type,\r\n        splitType: data.splitType || \"SHARED\",\r\n        status: data.status || \"PENDING\",\r\n        categoryId: data.categoryId,\r\n        accountId: data.accountId,\r\n        payerId: data.payerId,\r\n        ownerId: data.ownerId || null,\r\n      },\r\n      include: {\r\n        category: true,\r\n        account: true,\r\n        payer: true,\r\n      },\r\n    });\r\n    return NextResponse.json(transaction);\r\n  } catch (error) {\r\n    console.error(\"Error creating transaction:\", error);\r\n    return NextResponse.json(\r\n      { error: \"Failed to create transaction\" },\r\n      { status: 500 },\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,eAAe,MAAM,gIAAM,CAAC,WAAW,CAAC,QAAQ,CAAC;YACrD,SAAS;gBACP,UAAU;gBACV,SAAS;gBACT,OAAO;gBACP,OAAO;YACT;YACA,SAAS;gBAAE,cAAc;YAAO;YAChC,MAAM;QACR;QACA,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA+B,GACxC;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,cAAc,MAAM,gIAAM,CAAC,WAAW,CAAC,MAAM,CAAC;YAClD,MAAM;gBACJ,aAAa,KAAK,WAAW;gBAC7B,QAAQ,KAAK,MAAM;gBACnB,cAAc,IAAI,KAAK,KAAK,YAAY;gBACxC,aAAa,KAAK,WAAW,GAAG,IAAI,KAAK,KAAK,WAAW,IAAI;gBAC7D,MAAM,KAAK,IAAI;gBACf,WAAW,KAAK,SAAS,IAAI;gBAC7B,QAAQ,KAAK,MAAM,IAAI;gBACvB,YAAY,KAAK,UAAU;gBAC3B,WAAW,KAAK,SAAS;gBACzB,SAAS,KAAK,OAAO;gBACrB,SAAS,KAAK,OAAO,IAAI;YAC3B;YACA,SAAS;gBACP,UAAU;gBACV,SAAS;gBACT,OAAO;YACT;QACF;QACA,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA+B,GACxC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}